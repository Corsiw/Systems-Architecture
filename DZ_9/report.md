# **Отчёт по работе: побитовая передача целого числа между процессами с использованием сигналов SIGUSR1 и SIGUSR2** Терехов Дмитрий 8 баллов.

## **1. Основные идеи решения**

### **1.1 Использование двух сигналов как битов**

* SIGUSR1 — передаёт бит **0**
* SIGUSR2 — передаёт бит **1**

Передатчик вызывает `kill(receiver_pid, SIGUSR1/2)` — таким образом один бит передаётся одним сигналом.

---

### **1.2 Проблема надёжности сигналов**

Сигналы не ставятся в очередь (за исключением Realtime), поэтому при быстрой последовательной отправке они теряются.

**Решение:** передатчик отправляет следующий бит только после получения подтверждения от приёмника.

---

### **1.3 Подтверждение (ACK)**

Приёмник после обработки сигнала вызывает:

```cpp
kill(sender_pid, SIGUSR1);
```

Этот SIGUSR1 символизирует «бит принят, можно отправлять следующий».
Sender выполняет ожидание:

```cpp
sigwaitinfo(&set, &info);
```

и только после этого отправляет следующий бит.

Так достигается надёжная, последовательная передача без потерь.

---

### **1.4 Начальная синхронизация**

Чтобы порядок ввода PID не влиял на работу:

* **Sender** блокирует SIGUSR1 *в самом начале*, чтобы не получить ACK раньше времени и не завершиться.
* **Receiver** после ввода PID и установки обработчиков отправляет *первый ACK*, сигнализируя отправителю.

Sender ждёт этот ACK, прежде чем запрашивать число и начинать передачу.

Такой механизм устраняет гонки старта и гарантирует корректную работу, даже если:

* receiver ввёл PID первым,
* sender ввёл PID первым,
* передатчик или приемник задержался перед вводом.

---

### **1.5 Обработка сигналов**

Receiver использует `sigaction` с `SA_SIGINFO`, чтобы узнать PID отправителя:

```cpp
void handler(int sig, siginfo_t* info, void*) {
    pid_t pid = info->si_pid;
    ...
}
```

Это позволяет игнорировать любые сигналы от процессов, отличных от того, чей PID был введён пользователем.

---

## **2. Обоснование оценки**

### **1. Потеря информации при передаче — не выше 4 баллов**

В данной реализации передача происходит строго по протоколу «бит → ACK → бит → ACK».
Сигналы не теряются, гонки устранены. Потери информации отсутствуют → **максимальный балл**.

---

### **2. Передача информации с задержкой — не выше 6 баллов**

Программа не использует задержки (`sleep/usleep`) для стабилизации передачи.
Ожидание реализовано через `sigwaitinfo()`, что является корректным и неблокирующим способом.
Это полностью соответствует требованию → **максимальный балл**.

---

### **3. Асинхронная передача — до 8 баллов**

* Передатчик и приёмник могут запускаться в любом порядке.
* PID можно вводить в любом порядке.
* Отработка сигналов полностью асинхронна.
* Передатчик работает как конечный автомат с ожиданием события (сигнала).
* Приёмник использует асинхронные обработчики (signal handler).

Всё это соответствует критерию асинхронной системы - **максимальный балл**.

---

## **3. Инструкция по запуску программ**

### **1. Компиляция**


```
g++ src/sender.cpp -o sender
g++ src/receiver.cpp -o receiver
```

---

### **2. Запуск**

Первый терминал:

```
./sender
```

Второй терминал:

```
./receiver
```

---

### **3. Ввод PID**

Каждая программа напечатает свой PID:

Пример:

```
Sender PID: 12345
Receiver PID: 23456
```

Пользователь вручную вводит PID другой программы.
Порядок ввода PID **не имеет значения**.

---
